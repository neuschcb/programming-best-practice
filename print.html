<!DOCTYPE HTML>
<html lang="zh_CN" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>软件开发最佳实践</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> 总览</a></li><li class="chapter-item expanded affix "><li class="part-title">分析</li><li class="chapter-item expanded "><a href="analyse/requirement_analysis.html"><strong aria-hidden="true">2.</strong> 需求分析</a></li><li class="chapter-item expanded "><a href="analyse/requirement_analysis.html"><strong aria-hidden="true">3.</strong> 成本分析</a></li><li class="chapter-item expanded affix "><li class="part-title">设计</li><li class="chapter-item expanded "><a href="design/ui_design.html"><strong aria-hidden="true">4.</strong> UI设计</a></li><li class="chapter-item expanded "><a href="design/api_design.html"><strong aria-hidden="true">5.</strong> API设计</a></li><li class="chapter-item expanded "><a href="design/micro_design.html"><strong aria-hidden="true">6.</strong> 微服务设计</a></li><li class="chapter-item expanded "><a href="design/secure.html"><strong aria-hidden="true">7.</strong> 安全性设计</a></li><li class="chapter-item expanded "><a href="design/choice.html"><strong aria-hidden="true">8.</strong> 选型</a></li><li class="chapter-item expanded affix "><li class="part-title">编码</li><li class="chapter-item expanded "><a href="code/project_structure.html"><strong aria-hidden="true">9.</strong> 项目结构</a></li><li class="chapter-item expanded "><a href="code/encapsulation.html"><strong aria-hidden="true">10.</strong> 封装</a></li><li class="chapter-item expanded "><a href="code/intercept.html"><strong aria-hidden="true">11.</strong> 拦截</a></li><li class="chapter-item expanded affix "><li class="part-title">测试</li><li class="chapter-item expanded "><a href="testing/index.html"><strong aria-hidden="true">12.</strong> 测试</a></li><li class="chapter-item expanded affix "><li class="part-title">部署</li><li class="chapter-item expanded "><a href="deploy/single.html"><strong aria-hidden="true">13.</strong> 单机部署</a></li><li class="chapter-item expanded "><a href="deploy/container.html"><strong aria-hidden="true">14.</strong> 容器部署</a></li><li class="chapter-item expanded affix "><li class="part-title">杂项</li><li class="chapter-item expanded "><a href="others/no_internet_programming.html"><strong aria-hidden="true">15.</strong> 关于内网开发</a></li><li class="chapter-item expanded "><a href="others/continuous-integration.html"><strong aria-hidden="true">16.</strong> 关于持续集成</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">软件开发最佳实践</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/neuschcb/programming-best-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="软件开发最佳实践伪"><a class="header" href="#软件开发最佳实践伪">软件开发最佳实践（伪）</a></h1>
<p>本文档是是记录项目开发过程中遇到的问题和解决方法的记录，为其他项目开发过程作参考。</p>
<h2 id="起因"><a class="header" href="#起因">起因</a></h2>
<p>笔者团队是由大学生和研究生组成的，跟随老师和研究生学长开发了一个项目。此前团队内并没有开发项目的经验，甲方也没有提供相应支持的经验，二者都是两眼一抹黑，最后导致整个项目的开发体验非常地稀碎。这种稀碎不只是甲方的问题，也有团队内部的问题，在开发中对我们双方都造成了很大的困扰。</p>
<p>在经历了比较折磨的开发流程后，我们终于是把产品交付了，在所有的后置工作都完成之后，在老师的建议下，我们决定对项目从需求分析到最终交付的全过程中所遇到的各种问题和收获合成一个文档，供老师和学长所在的研究团队的其他项目进行参考。</p>
<h2 id="内容"><a class="header" href="#内容">内容</a></h2>
<p>正如上文所说，本文档中包含了我们项目开发过程中遇到的所有问题，同时也包含了在开发过程中我们不断地修正项目得到的经验。这些内容比较粗浅甚至可能包含了大量的错误，但我们还是选择将这些经验以文字的形式共享出来，一方面既是对自己的警示，也是为其他人提供一个参考，另一方面也希望对此类问题比较熟悉的大牛斧正该文档的内容。</p>
<p><em><strong>请注意：本文中并不会或只会有限的的包含对某些名词的一般性解释，主要是写我们粗浅的经验，故并不适合对项目开发或编码，设计等没有任何经验的同学查看或请结合其他资料进行理解。</strong></em></p>
<p>我们将这个文档分为了几个部分，分别是：</p>
<ul>
<li>分析</li>
<li>设计</li>
<li>编码</li>
<li>测试</li>
<li>部署</li>
<li>杂项</li>
</ul>
<p>每个部分都有一个或几个子项，基本涵盖了软件开发的全过程，谨供各位参考。</p>
<h2 id="实例简介"><a class="header" href="#实例简介">实例简介</a></h2>
<p>本文的实例为本团队开发的该项目，在以后的文章中均以本项目指代。</p>
<p>本项目是实现一个使用大数据相关技术对某人进行分析的软件，从形式上是某单位某部门的现有业务流程的<code>enhancement</code>。本项目使用了Springboot， Mybatis-plus， SpringData JPA，SpringData Neo4j，ActiveMQ ，Spark，Redis，OpenResty没有使用日志框架。</p>
<p>本项目分为五个部分：前端，后端，图数据库及相关后端，算法微服务以及网关</p>
<h2 id="copyright"><a class="header" href="#copyright">Copyright</a></h2>
<p>本文档的初版笔者是参与了软件开发的lony2003，kongqingxia，以及DymaticPro（TODO：问他Github昵称）编写，其他的贡献者请参考本文的Github页面。</p>
<p>同时本文档欢迎本科研团队的所有同学或老师参与完善，也欢迎其他同学、老师提出问题和修改意见。</p>
<p>本文开源在Github中并部署于Github Pages，感谢微软和Github给我们这个白嫖的机会 [doge]</p>
<p>本文遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0 （署名-非商业性使用-相同方式共享 4.0 国际）</a> 协议开源，使用时请遵守相关条款。</p>
<p>Powered by <a href="https://rust-lang.github.io/mdBook/">mdBook</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="需求分析"><a class="header" href="#需求分析">需求分析</a></h1>
<h2 id="方法"><a class="header" href="#方法">方法</a></h2>
<p>需求分析是项目管理和软件开发中至关重要的阶段，它确保项目团队对项目目标和用户需求有清晰的理解。在进行需求分析时，需要注意以下几个关键方面：</p>
<pre><code>明确定义项目范围： 确保明确项目的整体范围和目标。理解项目的边界和涵盖的功能，防止在后续阶段发生范围蔓延。
与利益相关者沟通： 与项目相关的各方进行充分的沟通，包括项目发起人、最终用户、业务分析员等。了解他们的期望和需求，以便更好地满足他们的期望。
识别和管理需求： 将需求划分为不同的类型，例如功能性需求、非功能性需求和约束性需求。确保需求是可管理的，能够在整个项目周期内进行追踪和变更。
建立优先级： 对需求进行优先级排序，以确保在有限资源下首先满足最重要的需求。这有助于确保项目在有限的时间内交付关键功能。
验证和确认需求： 通过与利益相关者的验证和确认，确保对需求的理解是准确的。这有助于避免由于误解或沟通不足而引起的问题。
考虑未来的可扩展性： 需求分析时要考虑到未来的变化和扩展。尽量设计灵活的系统，以便在将来轻松地适应新的需求。
避免过度工程： 避免在项目中包含不必要或过度复杂的功能。确保每个需求都有其明确的业务目的，并能够为项目的成功做出贡献。
文档化和追踪： 将所有需求详细记录，并确保在项目的整个生命周期中进行跟踪。这有助于团队了解项目的状态，追踪变更，并提供清晰的项目文档。
风险管理： 识别和评估与需求相关的风险。这有助于提前预测潜在的问题并采取适当的措施来降低风险。
团队协作： 确保需求分析是一个团队协作的过程。涉及到的团队成员应该共同参与，确保他们对需求有共同的理解。
</code></pre>
<p>我们总结了需求分析的流程如下：了解现状-&gt;了解痛点-&gt;了解形式-&gt;了解边界-&gt;提出解决方案。</p>
<p>其中了解项目的开发形式和了解边界是我们觉得对开发的影响最大的部分，如本项目其实一直对于项目形式不是很明确（其实这其中一大部分原因是因为我们也不知道我们能拿到什么数据和API，强烈建议需求分析过程中一定要明确的了解到底能拿到什么，这对设计流程是一大助力），开发过独立的系统和现有系统进行集成，也提出过对原有的系统进行改造，最后还是开发了一个独立的系统。</p>
<p>了解边界主要是确定开发什么不开发什么，笔者个人认为这是对本人影响最大的东西，本人就经常对项目做出超出边界的构想，这在实践中其实是有问题的，如果新的项目需要做需求分析强烈建议确定好边界并以文档的形式固定下来。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="需求分析-1"><a class="header" href="#需求分析-1">需求分析</a></h1>
<h2 id="方法-1"><a class="header" href="#方法-1">方法</a></h2>
<p>需求分析是项目管理和软件开发中至关重要的阶段，它确保项目团队对项目目标和用户需求有清晰的理解。在进行需求分析时，需要注意以下几个关键方面：</p>
<pre><code>明确定义项目范围： 确保明确项目的整体范围和目标。理解项目的边界和涵盖的功能，防止在后续阶段发生范围蔓延。
与利益相关者沟通： 与项目相关的各方进行充分的沟通，包括项目发起人、最终用户、业务分析员等。了解他们的期望和需求，以便更好地满足他们的期望。
识别和管理需求： 将需求划分为不同的类型，例如功能性需求、非功能性需求和约束性需求。确保需求是可管理的，能够在整个项目周期内进行追踪和变更。
建立优先级： 对需求进行优先级排序，以确保在有限资源下首先满足最重要的需求。这有助于确保项目在有限的时间内交付关键功能。
验证和确认需求： 通过与利益相关者的验证和确认，确保对需求的理解是准确的。这有助于避免由于误解或沟通不足而引起的问题。
考虑未来的可扩展性： 需求分析时要考虑到未来的变化和扩展。尽量设计灵活的系统，以便在将来轻松地适应新的需求。
避免过度工程： 避免在项目中包含不必要或过度复杂的功能。确保每个需求都有其明确的业务目的，并能够为项目的成功做出贡献。
文档化和追踪： 将所有需求详细记录，并确保在项目的整个生命周期中进行跟踪。这有助于团队了解项目的状态，追踪变更，并提供清晰的项目文档。
风险管理： 识别和评估与需求相关的风险。这有助于提前预测潜在的问题并采取适当的措施来降低风险。
团队协作： 确保需求分析是一个团队协作的过程。涉及到的团队成员应该共同参与，确保他们对需求有共同的理解。
</code></pre>
<p>我们总结了需求分析的流程如下：了解现状-&gt;了解痛点-&gt;了解形式-&gt;了解边界-&gt;提出解决方案。</p>
<p>其中了解项目的开发形式和了解边界是我们觉得对开发的影响最大的部分，如本项目其实一直对于项目形式不是很明确（其实这其中一大部分原因是因为我们也不知道我们能拿到什么数据和API，强烈建议需求分析过程中一定要明确的了解到底能拿到什么，这对设计流程是一大助力），开发过独立的系统和现有系统进行集成，也提出过对原有的系统进行改造，最后还是开发了一个独立的系统。</p>
<p>了解边界主要是确定开发什么不开发什么，笔者个人认为这是对本人影响最大的东西，本人就经常对项目做出超出边界的构想，这在实践中其实是有问题的，如果新的项目需要做需求分析强烈建议确定好边界并以文档的形式固定下来。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ui设计"><a class="header" href="#ui设计">UI设计</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="api设计"><a class="header" href="#api设计">API设计</a></h1>
<p>这个部分没什么好说的，参照行业内的规范即可，本项目中使用的是类似于Restful的形式，舍弃了一定的表意元素，只是用GET和POST请求方式，其他部分和Restful基本一致。在API文档的选择上，我们选择了OpenAPI 3.1的格式，使用swagger进行展示，使用Apicurio Studio平台进行设计。</p>
<p>相关文档：</p>
<p><a href="https://zhuanlan.zhihu.com/p/334809573">一文搞懂什么是RESTful API - 知乎</a></p>
<p><a href="https://spec.openapis.org/oas/latest.html">OpenAPI Specification v3.1.0</a></p>
<p><a href="https://www.apicur.io/studio/">Apicurio Studio</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="微服务设计"><a class="header" href="#微服务设计">微服务设计</a></h1>
<p>做微服务设计一方面是为分布式做准备，另一方面也是对于异构的项目来说必须经理的设计。本项目中使用了springboot，scala（spark），python作为项目语言，且在实践过程中发现springdata jpa和springdata neo4j存在冲突，需要分开，故必须对项目的微服务进行设计。</p>
<p>本项目中微服务间交互使用http协议，使用openfeign封装好的方式实现请求，该方案无需对编码人员增加太多的负担，编码人员只需要完成http接口的编写即可进行rpc，这是非常好的rpc方案。当然，涉及到多语言（Java，Go，Rust等混合）同时使用的时后，也可以去寻找其他普适性的框架，如grpc等，但就本项目而言，并不需要grpc来提升性能，相比Spark实时计算造成的耗时，json解析的耗时实在是不算什么了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安全性设计"><a class="header" href="#安全性设计">安全性设计</a></h1>
<p>项目的安全性设计是项目设计中很重要的部分，即使你的项目并不安全你也要设计的看起来很安全。这其中有一定的技巧，比如引入验证码，https，操作确认等前端组件的设计，又比如良好的鉴权逻辑。最简单的鉴权逻辑应该是在网关层设置一层拦截过滤器，对不带token的请求进行拦截，这种操作是网关几乎都有的功能，查阅你选择的网关即可。</p>
<p>关于账号登录的设计，我们的建议是参考<code>OAuth</code>，<code>OpenID Connect</code>等成熟的协议并加以适当的增删和修改，必要的时候可以使用<code>keycloak</code>等服务来进行账号登录逻辑的开发。</p>
<p>对于token，如果是单后端，没有微服务，没有分布式，那其实session和jwt都是不错的选择，但像本项目一样存在多个后端的话，那最好还是使用jwt作为鉴权的token，或者使用redis存储session信息，不要使用原生的session。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="选型"><a class="header" href="#选型">选型</a></h1>
<p>项目的选型其实非常简单，只要遵循如下的原则：</p>
<ul>
<li>除了项目核心功能的实现外，所有的选型全部选择成熟的开源项目</li>
<li>选择文档完善，用的人较多的开源项目</li>
<li>如果你不确定该项目是否可用，那就先选择它，但注意要在其上再封装一层，方便随时替换</li>
<li>重要的部分选择重量级的项目，不太重要的部分选择轻量的项目</li>
<li>选择简单易用好理解的开源项目</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="项目结构"><a class="header" href="#项目结构">项目结构</a></h1>
<p>项目结构是本项目二阶段接手后最大的问题。结构不清晰，命名模糊，过度分包等问题在本项目第一阶段代码中得到了充分的体现。项目结构本应该是设计阶段就确定好的，但编码习惯有可能将设计完善的代码结构变得再次混乱。在二阶段的开发过程中，我们遵循了如下的开发规范：</p>
<ul>
<li>
<p>Controller层不包含任何业务逻辑，只作为Service层代码的wrapper使用，具体业务逻辑均在Service层中实现。</p>
</li>
<li>
<p>Service层分为两层，ControllerService和Service，ControllerService调用Service，通常一个ControllerService可以调用多个Service，Controller调用ControllerService，通常一个Controller只能调用一个ControllerService。</p>
</li>
<li>
<p>Service层所有基础类均为接口，另有单独的Impl类做具体实现（Impl类注册时注册为接口名称）</p>
<p>我们强烈建议在新项目开发时也遵循上述的规则，既方便替换，也方便生成假数据。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="封装"><a class="header" href="#封装">封装</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="拦截"><a class="header" href="#拦截">拦截</a></h1>
<p>TODO</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="测试"><a class="header" href="#测试">测试</a></h1>
<pre><code>安全测试
    密码安全性问题
        在软件测试过程中，安全性问题是一个非常重要的方面，因为它关乎到系统和用户的信息安全。测试中使用的数据可能包含敏感信息，如个人身份信息、信用卡号码等。在测试过程中，必须确保这些敏感数据得到妥善处理，不会被泄露或滥用。在测试过程中，我们重点对登录功能安全性进行了处理。其中，测试人员需要验证系统在存储用户密码时是否采用安全的加密算法，如哈希函数，并是否使用适当的加盐机制。加盐可以防止彩虹表攻击，提高密码的安全性。而在确保在用户登录时，密码通过加密的传输层协议（如TLS或SSL）进行传输。这有助于防止中间人攻击，确保用户输入的密码在传输过程中不被窃取或篡改。我们还在系统中实施了强密码策略，包括密码长度、复杂性要求、定期密码更改等。测试应覆盖各种密码输入情境，确保系统正确地执行密码策略同时，由于系统支持多因素身份验证，测试其安全性。确保第二因素的传输和存储也是安全的，并测试在多因素身份验证场景下系统的整体安全性。在核查宝系统中，我们支持领导和普通管理员两种身份，因此测试这两种身份的整体安全性是十分重要的。最后，输入密码多次尝试失败后封禁账号是一种常见的安全策略，旨在防范恶意攻击者通过暴力破解密码的方式尝试入侵用户账户。这种策略有助于提高账户的安全性，但同时需要谨慎设计，以免影响正常用户的体验。
    验证码安全性问题
        验证码在安全性方面起到了重要的作用，主要用于验证用户身份、防止自动化攻击和确保用户与系统的交互安全。然而，在设计和使用验证码时，仍然可能面临一些安全性问题。恶意攻击者可能使用自动化工具，如爬虫或机器学习算法，来识别和破解验证码。测试应该验证验证码对抗自动化攻击的效果，确保其足够复杂和多样性，难以被自动程序破解。因此，我们选择后端生成验证码。后端生成验证码是一种用于验证用户身份、防范自动化攻击的常见安全策略。系统可以选择不同类型的验证码，如数字验证码、字母验证码、数字与字母组合的验证码、数学运算验证码等。验证码的类型应该根据具体的安全需求和用户体验来选择。验证码的长度通常是可配置的，根据安全要求可以选择适当的长度。一般来说，验证码长度越长，破解的难度就越大。系统可以设置验证码的复杂性，包括使用大小写字母、数字、特殊字符等。增加验证码的复杂性可以提高安全性，但也需要注意不要使验证码过于复杂而难以识别。为了防止验证码被攻击者截获后长时间使用，验证码通常具有一定的过期时间。过期时间可以根据具体需求进行配置，例如设置为几分钟。同时，我们也要确保每个验证码的唯一性，防止攻击者通过重复使用相同的验证码进行攻击。使用合适的算法和策略确保验证码的唯一性。如果验证码需要通过网络传输到客户端，确保在传输过程中采用安全的通信协议，如HTTPS，以防止中间人攻击。对于需要频繁刷新验证码的场景，我们还要考虑实现动态刷新机制，减少恶意攻击的可能性。

性能测试
    性能测试是在软件开发过程中关键的一环，主要用于评估系统在不同负载条件下的性能、稳定性和可伸缩性。在进行性能测试时，可能会遇到一些常见的问题，下面是其中一些问题的描述：
        定义合适的性能指标： 在性能测试之前，需要明确定义系统的性能指标，例如响应时间、吞吐量、并发用户数等。不清晰或不准确的性能指标可能导致对系统性能的错误评估。
        负载模拟的真实性： 确保负载测试使用的负载模拟是真实和准确的。如果负载模拟不符合实际使用场景，测试结果可能不具有实际参考价值。
        测试环境的还原性： 测试环境的还原性是指测试环境是否能够准确地还原生产环境的特性。如果测试环境与生产环境存在显著差异，测试结果可能不准确。
        并发用户数设置： 确定适当的并发用户数是一个挑战。设置过低可能无法发现系统在高负载下的性能问题，而设置过高可能导致系统崩溃。需要根据系统的预期使用情况来调整并发用户数。
        测试数据的真实性： 使用真实和合适的测试数据对性能测试至关重要。如果测试数据不真实或不具有代表性，测试结果可能无法反映系统在真实场景下的表现。
        测试工具选择： 选择合适的性能测试工具是至关重要的。不同的工具适用于不同的场景，选择不当可能导致测试结果的不准确性。
        测试时间的选择： 性能测试应该在软件开发的早期阶段开始，并且要在整个软件生命周期中定期进行。选择测试的时间点不当可能导致对系统性能问题的遗漏。
        性能监控和分析： 确保在性能测试期间进行全面的监控和分析。及时识别和解决性能问题需要有效的监控工具和分析手段。
        持续集成的性能测试： 将性能测试整合到持续集成和持续交付流程中，确保每次代码更改都能进行必要的性能验证。
        容量规划： 根据性能测试结果进行容量规划，确保系统能够满足未来的用户和负载增长。

测试时遇见的问题
    origin和refer匹配问题
        在Web开发中，Origin 和 Referer（注意拼写是Referer而不是Referrer，尽管规范中使用的是Referrer，但由于历史原因，浏览器普遍使用Referer）是两个HTTP头字段，用于标识请求的来源。这两者经常用于实施跨站请求伪造（CSRF）和跨站脚本攻击（XSS）的防御机制。
        Origin： Origin 是一个包含协议、域名和端口的字符串，用于表示请求的来源。例如，https://www.example.com 是一个Origin。浏览器在发送跨源请求时，会将请求的Origin信息包含在请求头中。服务器可以通过检查这个信息来确定是否允许跨源请求。
        Referer： Referer 是一个包含完整URL的字符串，表示引导用户代理（通常是浏览器）发送当前请求的来源。例如，如果用户从https://www.example.com/page1点击链接跳转到https://www.example.com/page2，那么在发送到page2的请求头中会包含Referer: https://www.example.com/page1。

    server暴露使用的技术resty和jetty
        Resty 不是一个独立的服务器，而是一个基于 OpenResty 平台的 Lua web 框架。OpenResty（也被称为 ngx_openresty）是一个集成了 Nginx 服务器和一系列常用的第三方模块的高性能 Web 平台。
        OpenResty 提供了一种在 Nginx 服务器上通过 Lua 编程语言扩展和定制服务器行为的方法。Resty 则是一个基于这个平台的框架，它使得在 Nginx 中使用 Lua 编写的 web 应用变得更加简单和方便。
        Resty 主要用于构建基于 Nginx 的高性能、低延迟的 Web 服务，特别适用于处理大量并发请求的场景。
        Jetty：
        Jetty 是一个开源的、灵活的 Java HTTP 服务器和 Servlet 容器。它可以嵌入到 Java 应用程序中，也可以作为独立的服务器运行。
        Jetty 提供了一种轻量级、灵活的方式来构建 Java Web 应用程序，支持 Servlet、WebSocket、HTTP/2 等标准。Jetty 的嵌入式特性使得将其嵌入到应用程序中变得相对简单，同时也支持作为独立的服务器运行。
        Jetty 在 Java 生态系统中广泛应用，特别是在构建嵌入式应用、微服务、以及各种 Java Web 应用程序方面。
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="单机部署"><a class="header" href="#单机部署">单机部署</a></h1>
<p>由于项目要求，对于本项目来说，所有和业务相关的服务都是以最普通的方式部署的，其中包含了两个部分：</p>
<p>业务部分：Back, Neo4jBack, DatabaseBack, SparkBack, Front（OpenResty）</p>
<p>支撑部分：KingBase, Minio, Redis, OpenResty, Neo4j</p>
<p>其中支撑部分的部署我个人认为是比较成功的，业务部分的部署是存在一定的问题的。首先运行为纯后台运行，且服务下线后并没有完善的恢复流程，这其实是比较失败的设计。我个人认为最简单的也最好用的其实是用 SystemV 风格（init.d）或者 systemd （Service, systemctl）去管理服务，事实上本项目中支撑部分的部署就是上传二进制包然后写systemd脚本实现的，业务部分也理应如此，不过由于某些原因导致目前服务的部署还是原始的后台进程的方式，在新项目时不应该再出现类似的情况。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="容器部署"><a class="header" href="#容器部署">容器部署</a></h1>
<p>本项目中与开发相关的服务部署在中容器中进行，包括代码仓库，maven及npm服务器，API文档平台等服务，在本项目刚接触到内网环境时，本人预期的容器化方案其实是systemd-nspawn（可以看作chroot的高级版），但很可惜在设计之初并没有考虑到服务器的支持情况，导致封装的所有服务都起不来，统一部署在一个环境下又会对环境造成一定的影响，故最终选择了使用Docker。在容器部署环节少不了镜像拉取环节，这个部分只能是尽量的满足，实在不行找替换。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于内网开发"><a class="header" href="#关于内网开发">关于内网开发</a></h1>
<p>本项目中遇到了大量的需要进行内网开发的场景，这时候仅有一个代码编辑器是远远不够的，需要在内网部署一套开发环境。经过本人的测试，适合在内网环境下部署的开发环境有：</p>
<ul>
<li>
<p>nexus 3：maven及npm私服（但是填充仓库稍有些麻烦）</p>
</li>
<li>
<p>gitlab ce：git仓库</p>
</li>
<li>
<p>portainer：Docker管理</p>
</li>
<li>
<p>yapi：API文档及测试平台（版本众多，无法推荐好用的版本）</p>
<p>安装好上述环境即可以得到一个相对舒适的基本内网开发环境。当然，有一台可以联网的堡垒机其实是最好的选择，但是大多数情况下并没有相应的条件，所以只能适应环境了。</p>
<p>其实根据软件项目开发的全流程来讲，还应该有一些其他的工具，比如项目管理，异常统计等还需要添加一些其他的服务，但在时间有限的情况下，部署好上述四个服务即可以开始开发了。</p>
</li>
</ul>
<p>注：其实最好的内网开发方式是不进行内网开发，至少不要在一个毛皮房内进行内网开发，如果一个项目的内网环境没有任何的基础设施，需要你自己搭建的话，那我的建议还是不要把所有的开发过程放在内网环境中，设计好数据schema然后出一两个人对数据库中的数据进行分析，最后做ETL可能是更好的选择，但如果你非要进行内网开发的话，那我只能祝你好运，并希望你能正确的部署上述的基础设施了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="关于持续集成"><a class="header" href="#关于持续集成">关于持续集成</a></h1>
<p>在项目开发过程中，其实本人有考虑过利用Gitlab自带的runner功能对业务微服务进行CI/CD改造，但最后由于各方面的原因并没有真实落地。建议新项目在建立之初就考虑充分利用CI/CD服务，对所有人都方便。</p>
<p>其实也不需要太高深的CI/CD技术，只需要写一个Shell脚本跑通编译，部署，重启服务流程即可，但很可惜，在一个光秃秃的环境中我们实在是无法实现，希望下次在开发新项目的过程中可以好好的实践CI/CD。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
